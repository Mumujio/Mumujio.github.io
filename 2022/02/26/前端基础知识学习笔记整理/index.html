<!DOCTYPE html>

   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-circle.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="学习笔记," />










<meta name="description" content="JavaScript 篇导读 DOM（网页文档对象模型） BOM(浏览器对象模型） JS 三种书写位置：  内嵌式  行内式  外部嵌入式   Js 注释：  单行注释：&#x2F;&#x2F; （Ctrl + &#x2F;)  多行注释：&#x2F;* *&#x2F; (alt + Ctrl + a)   JS 输入输出语句：  alert() (浏览器弹出警示框）  prompt() (用户输入框）  console.log() (控制台输出">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础知识学习笔记">
<meta property="og:url" content="http://example.com/2022/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="木木卓的小窝">
<meta property="og:description" content="JavaScript 篇导读 DOM（网页文档对象模型） BOM(浏览器对象模型） JS 三种书写位置：  内嵌式  行内式  外部嵌入式   Js 注释：  单行注释：&#x2F;&#x2F; （Ctrl + &#x2F;)  多行注释：&#x2F;* *&#x2F; (alt + Ctrl + a)   JS 输入输出语句：  alert() (浏览器弹出警示框）  prompt() (用户输入框）  console.log() (控制台输出">
<meta property="og:locale">
<meta property="og:image" content="c:/Users/JayZ/blog/public/images/1.png">
<meta property="og:image" content="c:/Users/JayZ/blog/public/images/2.png">
<meta property="og:image" content="c:/Users/JayZ/blog/public/images/3.png">
<meta property="og:image" content="https://github.com/Mumujio/photoRepository/raw/master/github%E5%9B%BE%E7%89%87/photo/%E5%8E%9F%E5%9E%8B%E9%93%BE.png?raw=true">
<meta property="og:image" content="https://github.com/Mumujio/photoRepository/raw/master/github%E5%9B%BE%E7%89%87/photo/Js%E7%9A%84%E6%88%90%E5%91%98%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6.png?raw=true">
<meta property="og:image" content="https://github.com/Mumujio/photoRepository/raw/master/github%E5%9B%BE%E7%89%87/photo/4.png?raw=true">
<meta property="og:image" content="c:/Users/JayZ/Desktop/markdow图片/5.png">
<meta property="article:published_time" content="2022-02-26T06:49:35.000Z">
<meta property="article:modified_time" content="2022-03-11T13:06:50.879Z">
<meta property="article:author" content="林卓">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/JayZ/blog/public/images/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2022/02/26/前端基础知识学习笔记整理/"/>





  <title>前端基础知识学习笔记 | 木木卓的小窝</title>
  








<meta name="generator" content="Hexo 5.4.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">木木卓的小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://tse1-mm.cn.bing.net/th/id/R-C.8d895e16bbb22a83310865f234dd9f3f?rik=VxdPPnUQI85owQ&riu=http%3a%2f%2f5b0988e595225.cdn.sohucs.com%2fimages%2f20191230%2fa7b693fd6434409585045f5887583e7c.jpeg&ehk=0aIPIvL4wupp6ImoUjS%2fxpd0ULtX5T6li3I%2fbywpfHo%3d&risl=&pid=ImgRaw&r=0">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木木卓的小窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端基础知识学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-26T14:49:35+08:00">
                2022-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E6%AC%A1%E6%95%B4%E7%90%86%EF%BC%89/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记（二次整理）</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2022/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2022/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JavaScript-篇"><a href="#JavaScript-篇" class="headerlink" title="JavaScript 篇"></a>JavaScript 篇</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>DOM（网页文档对象模型） BOM(浏览器对象模型）</li>
<li>JS 三种书写位置：<ol>
<li> 内嵌式</li>
<li> 行内式</li>
<li> 外部嵌入式</li>
</ol>
</li>
<li>Js 注释：<ol>
<li> 单行注释：// （Ctrl + /)</li>
<li> 多行注释：/* */ (alt + Ctrl + a)</li>
</ol>
</li>
<li>JS 输入输出语句：<ol>
<li> alert() (浏览器弹出警示框）</li>
<li> prompt() (用户输入框）</li>
<li> console.log() (控制台输出）</li>
</ol>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>变量是内存中申请一块用来存放数据的空间</li>
</ul>
<h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><ul>
<li>变量的初始化：var name = ‘linzhuo’ ;</li>
</ul>
<h3 id="变量的语法拓展"><a href="#变量的语法拓展" class="headerlink" title="变量的语法拓展"></a>变量的语法拓展</h3><ol>
<li>更新变量：以最后一次赋的值为准</li>
<li><strong>声明不赋值结果是 undefined</strong></li>
<li>不声明直接赋值使用（JS 允许，但是不建议）</li>
<li>变量的命名规范：<ol>
<li>由字母、数字、下划线、$组程</li>
<li>严格区分大小写</li>
<li>不能以数字开头</li>
<li>不能使用关键字、保留字命名</li>
<li>遵守驼峰命名法： 首字母小写，后面的单词首字母要大写 MyFirstName</li>
</ol>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>JS 是一种弱类型动态语言（类型会在程序运行过程中被自动确定）</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>简单数据类型：<ul>
<li>Numbe 数字型：1，2，3<ol>
<li>八进制：数字前面加 0 010（8）、</li>
<li>十六进制：数字前面加 0x 0xa(10)</li>
<li>NaN：非数字类型</li>
</ol>
<ul>
<li>isNaN()：判断非数字 是数字返回 false 不是数字 true</li>
</ul>
</li>
<li>Boolean 布尔值类型：true(1) false(0)<ul>
<li>true 参与运算算作 1，false 为 0</li>
</ul>
</li>
<li>String 字符串类型：‘我好帅’<ol>
<li>str.length：检测字符串的长度（包含空格）</li>
<li>引号嵌套（外单内双，外双内单）</li>
<li>转义字符：\n \t 等等</li>
<li>字符串的拼接：‘+’ （只要有字符串和其他类型的相拼接最终是字符串类型）（变量不能添加引号）</li>
</ol>
</li>
<li>Undefined：未定义数字类型<ul>
<li>undefined 和数字相加结果是 NaN</li>
</ul>
</li>
<li>Null：空值</li>
</ul>
</li>
</ol>
<ul>
<li>typeof：获取变量的数据类型<ul>
<li>prompt 和表单取过来的值为 string 类型</li>
<li>控制台：黑色（字符串型） 深蓝色（数字型） 蓝色（布尔型） 灰色（null 和 undefined)</li>
</ul>
</li>
<li>数字型转换为字符型<ul>
<li>变量.toString ()</li>
<li>String (变量)</li>
<li>用’+’拼接空字符串</li>
</ul>
</li>
<li>转换为数字型<ul>
<li>parseInt(变量)：转换为整数数字型（小数会取整）（可去掉 px 等单位）、</li>
<li>parseFloat(变量）：转换为浮点数字型</li>
<li>Number(变量）：转换为数字型</li>
<li>隐式转换：（’12’ * 0) // 12 ( * * / 都可以）</li>
</ul>
</li>
<li>转换为布尔型<ul>
<li>Boolean()函数：“空 0 NaN null undefined”会被转为 false，其余都为 true</li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><ul>
<li>浮点数运算会有问题（0.2 + 0.1 ！= 0.3）（0.7 * 10 ！=7）（我们不能直接拿浮点数来进行比较是否相等）</li>
<li>递增运算符：<ol>
<li> 前置：++age // 类似于 age = age +1 (先自加 1，后返回值）</li>
<li> 后置：age++ // 单独使用类似于前置 （先返回原值，后自加 1）</li>
<li> var e =10; var f = e++ + ++e // f = 22</li>
</ol>
</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>会返回一个布尔值</li>
<li>== （默认转换数据类型）（ 18 == ‘18’) // true</li>
<li>=== (要求两侧的值 数据类型都要相等）</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>与 （&amp;&amp;）</li>
<li>或 （ || ）</li>
<li>非 （！）</li>
<li>短路运算：（逻辑中断后后面的代码不执行） 1. 逻辑与：如果表达式 1 为真 则返回表达式 2，反之 ； console.log（ 123 &amp;&amp; 456 ）// 456 (除 0 空 null undefined NaN 之外都为真） 2. 逻辑或：如果表达式 1 为真 则返回表达式 1，反之 ；</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li>+=：num+=2 // num = num + 2</li>
<li>*= /= *= 类似效果</li>
</ul>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><ul>
<li>先&amp;&amp; 后 ||</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>continue 关键字（退出本次循环 跳到 i++）</li>
<li>break 关键字用与跳出整个循环</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>声明函数 fuction 函数名() { 函数体 }</li>
<li>函数表达式声明函数（<strong>匿名函数</strong>） （var 变量名 = function() { 函数体 } )</li>
<li>函数不调用自己不执行</li>
<li>function 函数名（形参 1，形参 2…）{ }； 函数名 （实参 1，实参 2…）（ 形参是接受实参的）</li>
<li>JS 中实参和形参个数可以不一样，多的形参定义为 undefined</li>
<li>return 语句：<ul>
<li>函数名（）=return 后面的结果 （即把 return 后面的结果赋值给调用者）</li>
<li>return 后面的代码不会被执行</li>
<li>return 可以返回数组</li>
</ul>
</li>
<li>函数中没有 return 会返回 undefined</li>
<li>函数可以调用另外一个函数</li>
</ul>
<h2 id="JS-作用域"><a href="#JS-作用域" class="headerlink" title="JS 作用域"></a>JS 作用域</h2><ul>
<li>代码名字（变量）在某个范围内起效果和作用：为了提高程序的可靠性，减少命名冲突）</li>
<li>JS 在 es6 之前分为：全局作用域 局部作用域</li>
</ul>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ul>
<li>分为全局变量和局部变量<ol>
<li> 全局变量：在全局作用域下的变量（在函数外声明的变量）（局部作用域下也起作用）</li>
<li> 局部变量：在局部作用于下的变量（在函数内声明的变量）（在函数内部 var 声明的变量是局部变量）</li>
</ol>
</li>
<li><strong>变量未声明也可以使用，会被变成全局变量</strong></li>
<li>函数的形参也可以看作是局部变量</li>
<li>全局变量比较占内存资源，局部变量比较节约资源</li>
<li><strong>es6 之前无块级作用域：if() for()中定义的变量为全局变量</strong></li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li>内部函数可以访问外部函数（访问有就近原则，沿着链查找直到找到为止）<strong>（就近原则）</strong></li>
</ul>
<h2 id="JS-预解析"><a href="#JS-预解析" class="headerlink" title="JS 预解析"></a>JS 预解析</h2><ul>
<li><strong>JS 执行：先预解析 再代码执行</strong><ol>
<li>预解析： JS 引擎会把 JS 里面所有的 var 还有 function 函数提升到当前作用域的最前面<ol>
<li>变量提升：把所有变量声明提升到当前作用域的最前面，不提升赋值操作</li>
<li>函数提升：把所有函数声明提升到当前作用域的最前面，不调用函数<strong>（函数表达式不提升）</strong></li>
</ol>
</li>
<li>代码执行：按照顺序从上至下执行<br> <img src="C:\Users\JayZ\blog\public\images\1.png" alt="预解析"><br> <img src="C:\Users\JayZ\blog\public\images\2.png" alt="预解析"></li>
</ol>
</li>
</ul>
<h2 id="JS-对象"><a href="#JS-对象" class="headerlink" title="JS 对象"></a>JS 对象</h2><ul>
<li>对象是属性和方法的集合</li>
</ul>
<h3 id="JS-对象的创建方式"><a href="#JS-对象的创建方式" class="headerlink" title="JS 对象的创建方式"></a>JS 对象的创建方式</h3><ol>
<li>利用字面量创建对象<br>var obj = { };<ul>
<li><strong>多个属性或者方法中间用逗号隔开</strong></li>
<li><strong>方法冒号后面跟的是一个匿名函数</strong></li>
<li>调用对象的属性<ol>
<li>对象名.属性名</li>
<li>对象名[‘属性名’]</li>
</ol>
</li>
<li>调用对象的方法<ul>
<li>对象名.方法名 ()</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>属性在对象里面不需要声明</li>
</ul>
<ol start="2">
<li><p>利用 new object 创建对象</p>
<ul>
<li>var obj = new Object();</li>
<li>利用等号赋值的方法添加对象的属性和方法 （obj.age=18; obj.sayHi = fuction (){ } )</li>
</ul>
</li>
<li><p>利用构造函数来创建对象</p>
<ul>
<li>可以一次创建多个对象，可以利用函数的方法重复这些相同的代码，函数里面封装的是对象<br>function 构造函数名(){this.属性 = 值；this.方法 = function(){  }  } ;<br>var name = new 构造函数名(  )</li>
<li><strong>构造函数名字的首字母要大写</strong></li>
<li>构造函数不需要return 就可以返回结果</li>
<li><strong>调用构造函数必须使用new</strong></li>
<li>只要new 构造函数名（） 调用函数就创建一个对象 函数名{ }</li>
<li>利用构造函数创造对象的过程称为<strong>对象实例化</strong></li>
</ul>
</li>
</ol>
<h3 id="new关键字的执行过程"><a href="#new关键字的执行过程" class="headerlink" title="new关键字的执行过程"></a>new关键字的执行过程</h3><ol>
<li>new构造函数先在内存中创建一个空的对象</li>
<li>this就会指向刚才创建的空对象</li>
<li>执行构造函数里的代码给空对象添加属性和方法</li>
<li>返回这个对象<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3></li>
</ol>
<ul>
<li>for in 遍历对象<ul>
<li>for (变量 in 对象名）{   }    // for (var k in obj){ console.log(k) //<strong>k得到属性名   console.log(obj[k]) //obj[k]得到的是属性值 }</strong></li>
</ul>
</li>
<li>for in 里面的变量写k或者key</li>
</ul>
<h3 id="JS的内置对象"><a href="#JS的内置对象" class="headerlink" title="JS的内置对象"></a>JS的内置对象</h3><ul>
<li>JS对象的分类：<ol>
<li>自定义对象</li>
<li>内置对象：JS中自带的对象，常用的功能（属性和方法）；帮助我们快速开发</li>
<li>浏览器对象</li>
</ol>
</li>
<li>查文档：MND文档  ，W3C</li>
<li>Math()对象</li>
<li>Date日期对象：是一个构造函数，使用new调用和创建</li>
<li>数组对象Array：<ul>
<li>创建数组的方式：<ol>
<li>利用字面量创建：var arr = [1，2，2]</li>
<li>利用new Array()：var arr = new Array(2，3)；//等价于[2,3]  只写一个值表示数组的长度为该值 不写代表空数组</li>
</ol>
</li>
<li>检测是否为数组<ol>
<li>instanceof 运算符：var arr = [ ] ;  console.log(arr instanceof Array)    //true</li>
<li>Array.isArray(参数）</li>
</ol>
</li>
<li>添加删除数组元素的方法<ol>
<li>push() 方法：在数组的末尾添加多个数组元素，返回的是新数组的长度</li>
<li>unshift() 方法：在数组的开头添加多个数组元素，返回的是新数组的长度</li>
<li>pop() 方法：删除数组的最后一个元素，返回删除的元素</li>
<li>shift() 方法：删除数组的第一个元素，返回删除的元素</li>
</ol>
</li>
<li>reverse() 方法：翻转数组</li>
<li>sort() 方法：数组排序（从小到大）（冒泡排序）<ul>
<li>arr.sort( fuction(a,b){  return a-b //升序 ；return a+b //降序  }  )</li>
</ul>
</li>
<li>indexOf() 方法：从前查找返回查找元素的索引(返回第一个满足条件的索引）（找不到返回-1)</li>
<li>lastIndexOf 方法：从后查找返回查找元素的索引(返回最后一个满足条件的索引）（找不到返回-1)</li>
<li>数组转换为字符串：<ol>
<li>toString()：数组转换为字符串</li>
<li>join(分隔符)：以分隔符分割字符串</li>
<li>concat()：连接数组；返回新数组</li>
<li>slice(begin,end)：截取数组；返回被截取的新数组</li>
<li>splice(第几个开始，要删除的个数，要增加的内容)：删除和插入新数组，会影响原数组</li>
</ol>
</li>
</ul>
</li>
<li>字符串对象：<ul>
<li><strong>基本包装类型</strong>：把简单数据类型  包装成为了  复杂数据类型，进而可以使用对象才有的属性和方法<ol>
<li>var temp = new String(‘andy’) （把简单数据类型  包装成为了  复杂数据类型）</li>
<li>str = temp (把临时变量的值给str）</li>
<li>temp = null （销毁这个临时变量）</li>
</ol>
</li>
<li>字符串的不可变：指向改变，开辟了新内存，但是原内存仍然存在（不要大量拼接字符串）</li>
<li>字符串所有的方法都不会修改字符串本身</li>
<li>str.indexOf(‘要查找的字符’，[起始的索引位置])：根据字符返回索引位置</li>
<li><strong>根据位置返回字符</strong>：<ol>
<li>charAt(indx)：根据位置返回字符</li>
<li>charCodeAt(index)：根据位置返回相应字符ASCII值   目的：判断用户按下了哪个键</li>
<li>str[index]：根据位置返回字符 （H5新增，有兼容性问题）</li>
</ol>
</li>
</ul>
</li>
<li><strong>拼接以及截取字符串</strong><pre><code>1. concat(字符串1，字符串2...)：拼接字符串
2. substr(截取的起始位置,截取的长度)：截取字符串
3. replace(被替换的字符，替换为的字符)：替换字符（只会替换第一个字符）
4. 字符转换为数组 split（&#39;分隔符&#39;)：字符串转换为数组（以字符串中的分隔符分割成数组）
</code></pre>
</li>
</ul>
<h2 id="数据类型的内存分配"><a href="#数据类型的内存分配" class="headerlink" title="数据类型的内存分配"></a>数据类型的内存分配</h2><ul>
<li>简单类型（值类型）：储存的是值本身，<strong>数据值放在栈空间里面</strong></li>
<li>复杂类型（引用类型）：变量在栈中储存的仅仅是地址十六进制（引用），栈里的地址再指向堆里的数据<strong>（数据值放在堆空间里面）</strong></li>
<li><strong>我们把一个值类型的变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，所以在方法内部对形参做任何修改，都不会影响到外部变量</strong></li>
<li><strong>当我们把引用类型变量传给形参时，把栈空间里的地址也传过去，所以在方法内部对形参做任何修改，都会影响到外部变量</strong></li>
</ul>
<h1 id="Web-API阶段"><a href="#Web-API阶段" class="headerlink" title="Web API阶段"></a>Web API阶段</h1><ul>
<li>API：应用程序的接口</li>
<li>Web API 是浏览器提供的操作浏览器功能和页面元素的API（BOM和DOM）</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li>DOM：文档对象模型，处理HTML或者X,ML的接口<br><img src="C:\Users\JayZ\blog\public\images\3.png"></li>
<li>文档：一个页面就是一个文档（document)</li>
<li>元素：页面中的标签就是元素（element)</li>
<li>节点：页面中的所有内容（标签、属性、文本、注释）都是节点（node)</li>
<li><strong>DOM把以上内容都看作是对象</strong></li>
</ul>
<h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul>
<li>console.dir()：打印返回的元素对象，更好的查看里面的属性和方法</li>
</ul>
<ol>
<li><ul>
<li>getElementById()：根据ID获取，返回的是一个对象</li>
</ul>
</li>
<li>getElementByTagName()：返回带有指定标签名的<strong>对象结合</strong>（伪数组的形式存储）（得到元素对象是动态）</li>
<li>element.getElementByTagName(‘标签名’)：获取某个父元素内部所有指定标签名的子元素 <strong>（父元素必须是单个对象）</strong></li>
<li>document.getElementByClassName( 类名)：根据类名获得某些元素集合 （HTML5新增）</li>
<li>document.querySelector( 指定选择器) ：返回指定选择器的第一个元素对象 （里面的选择器需要加符号：.   #)</li>
<li>document.querySelectorAll( 可指定选择器)：返回指定选择器的所有元素对象 （里面的选择器需要加符号：.   #)</li>
<li>获取body元素：document.body()（返回的是一个元素对象）</li>
<li>获取html元素：document.documentElement()</li>
</ol>
<h3 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h3><ul>
<li>事件三要素：<ol>
<li>事件源：事件被触发的对象  </li>
<li>事件类型：如何触发 什么事件</li>
<li>事件处理程序：通过一个匿名函数赋值的方式完成</li>
</ol>
</li>
<li>执行事件的步骤：<ol>
<li>获取事件源</li>
<li>注册事件（绑定事件）</li>
<li>添加事件处理程序（采取函数赋值形式）</li>
</ol>
</li>
</ul>
<h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h3><ul>
<li>改变元素内容(都是方法属性）：<ol>
<li>element.innerText （不识别html标签）（去除空格和换行）</li>
<li>element.innerHtml  （识别html标签）（不去除空格和换行）（推荐）</li>
</ol>
<ul>
<li>这两个属性是可读写的，可以获取元素里面的内容</li>
</ul>
</li>
<li>修改元素的属性：<ol>
<li>src,href,id,alt,title等等都可修改</li>
</ol>
</li>
<li>表单元素的属性操作<ul>
<li>事件函数内的this指向的是事件函数的调用者</li>
</ul>
</li>
<li>样式属性操作：<ol>
<li>element.style.：获得修改元素样式 (功能简单，样式少使用）</li>
<li>element.ClassName.： 给元素添加一个类名（修改的内容先在css中写好，需要的时候添加）（适合功能复杂，样式较多的情况）</li>
</ol>
</li>
<li><em>(JS里面的样式采取驼峰命名法）（JS修改style样式操作，产生的是行内样式，css权重比较高）（className 会直接更改掉原先的类名）</em>*<ul>
<li>多类名选择器：class=（’ 第一个类名  第二个类名     ‘ ）</li>
<li>自定义属性的操作：<ol>
<li>element.属性：获取属性值 (获取的是内置属性）</li>
<li>element.getAttribute (‘属性’)  （可获取自定义属性）  （自定义属性：程序员自己添加的属性）</li>
<li>element.属性=’值’：设置属性值（设置内置属性）</li>
<li>element.setAttribute（’属性’，值）：设置属性值（可设置自定义属性）</li>
<li>element.removeAttribute(‘属性’)：移除属性</li>
<li>element.dataset.自定义属性名：获取元素自定义属性 （H5新增）（获取的时候采取驼峰命名法）</li>
</ol>
</li>
</ul>
</li>
<li><strong>排他思想：干掉所有人（清除所有人的样式），保留我自己（然后自己再添加样式）</strong></li>
<li><strong>H5规定自定义属性data-开头作为属性名并且赋值</strong></li>
</ul>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ul>
<li>可利用节点的父子关系操作，逻辑性强，兼容性较差</li>
<li>页面中的所有内容都是节点：至少有 nodeType（节点类型）  nodeName（节点名称）  nodeValue（节点值）三个基本属性</li>
<li>得到节点<ul>
<li>父节点 element.parentNode：得到的是离元素最近的父级节点（如果指定节点没有父节点，就放回null）</li>
<li>子节点 element.childNodes：得到的是子节点的集合<strong>（包含元素节点，文本节点，如果只想获得里面的元素节点需要专门处理，不推荐）</strong></li>
<li>子节点 element.children：获取<strong>子元素节点集合</strong> （只获得元素节点）</li>
<li>parentNode.firstChild：获取第一个子节点（包括文本节点和元素节点等）</li>
<li>parentNode.lastChild：获取最后一个子节点（包括文本节点和元素节点等）</li>
<li>parentNode.firstElementChild：获取第一个子元素节点 （IE9以上才能用）</li>
<li>parentNode.lastElementChild：获取最后一个子元素节点（IE9以上才能用）</li>
<li>node.nextSibling：得到下一个兄弟节点（包括文本节点和元素节点等）</li>
<li>node.previousSibling：得到上一个兄弟节点（包括文本节点和元素节点等）</li>
<li>node.nextElementSibing：得到下一个兄弟<strong>元素节点</strong>（IE9以上才能用）</li>
<li>node.previousElementSibing：得到上一个兄弟<strong>元素节点</strong>（IE9以上才能用）</li>
</ul>
</li>
<li>页面中添加一个新的元素：<ol>
<li>创建元素</li>
<li>添加元素</li>
</ol>
</li>
<li>创建节点<ul>
<li>document.createElement (‘tagName’)：创建一个节点（动态创建的，原先不存在）</li>
</ul>
</li>
<li>添加节点（node 父级   child 子级）<ul>
<li>node.appendChild(child)：将一个节点添加到指定父节点列表的<strong>末尾</strong></li>
<li>node.insertBefore(child，指定元素）：将一个节点添加到父节点<strong>指定子节点的前面</strong></li>
</ul>
</li>
<li>删除节点（node 父级   child 子级）<ul>
<li>node.removeChild(child)：从DOM中删除一个子节点，返回删除的节点</li>
</ul>
</li>
<li>复制节点 <ul>
<li>node.cloneNode()：返回调用该方法的节点的一个副本 （括号参数为空或false，是浅拷贝，只复制标签不复制内容；括号里面为true，则还会   复制内容）</li>
</ul>
</li>
<li>三种动态创建元素的区别<ol>
<li>document.write（）：直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘</li>
<li>innerHTML：不会导致页面重绘,创建多个元素效率更高，（采用数字形式拼接字符串）</li>
<li>createElement（）：效率稍低，但是结构清晰</li>
</ol>
</li>
</ul>
<h3 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h3><ul>
<li><p>注册事件（绑定事件）：有两种方式：</p>
<ol>
<li>传统方式：注册事件唯一性（同一个元素只能设置一个处理函数，最后覆盖前面）</li>
<li>方法监听方式：推荐方式  (I9以上支持）<ul>
<li>eventTarget.addEventListener(‘type’,listener,[useCapture]) 事件监听方式：eventTarget (事件源）type (事件类型<strong>字符串</strong> <strong>不要带on</strong>)  ;listener (事件处理函数);  useCapture (可选参数，布尔值）  </li>
</ul>
</li>
</ol>
</li>
<li><p>删除事件（解绑事件）：两种方式：</p>
<ol>
<li>传统方式：eventTarget.onclick = null</li>
<li>方法监听注册方式：<ol>
<li>eventTarget.removeEventListener( ‘type’,listener) :注册事件时，执行函数单独写出来，在函数内移除自己，事件处理函数使用函数名不         加()</li>
<li>eventTarget.detachEvent(‘type’,listener)：IE8专用</li>
</ol>
</li>
</ol>
</li>
<li><p>DOM事件流：从页面中接收事件的顺序。三个阶段：</p>
<ol>
<li>捕获阶段：从外到内</li>
<li>当前阶段目标</li>
<li>冒泡阶段：从内到外</li>
</ol>
<ul>
<li>JS代码中只能执行捕获或冒泡的一个阶段</li>
<li>onclick 和 attachEvent(ie)只能得到冒泡阶段</li>
<li><strong>如果addEventListener第三个参数是 false 或者省略，那么则处于冒泡阶段；第三个参数是ture，那么则处于捕获阶段</strong></li>
<li>实际开发中很少使用事件捕获</li>
</ul>
</li>
<li><p>事件对象：var div = document.querySelector(‘div’) ;  div.onclick = function(event) {   }</p>
<ol>
<li>event 就是一个事件对象，写道侦听函数的小括号里，当形参看</li>
<li>事件对象只有有了事件才会存在，系统自动创建的，不需要传递函数</li>
<li>事件的一系列相关的一系列数据集合，跟事件相关的，比如鼠标点击里面就包含了鼠标的相关信息，如鼠标坐标鹊</li>
<li>事件对象可以我们自己命名 如：event、evt  等等</li>
<li>事件对象有兼容性问题，ie678通过window.event</li>
</ol>
<ul>
<li>常见事件对象的属性和方法：<ol>
<li>event.target：<strong>返回的是触发事件的对象或元素  （this只返回绑定事件的对象或元素）</strong></li>
<li>阻止默认行为（事件）：<ul>
<li>event.preventDefault()：阻止事件 （普通浏览器）</li>
<li>return false：阻止事件，无兼容性问题 （return后面的代码不执行，而且只限于传统的注册方式）</li>
<li><strong>阻止事件冒泡的方式</strong>：<ol>
<li>event.stopPropagation()   (兼容性问题）</li>
</ol>
</li>
</ul>
</li>
<li>事件委托（代理，委派）</li>
</ol>
<ul>
<li><strong>原理：不是每个子节点单独设置事件监听器，而是事件监听器设再其父节点上，然后利用冒泡原理影响每个子节点</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ul>
<li>浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象，核心对象是window</li>
<li>把浏览器当做一个对象</li>
<li>BOM再浏览器厂商各自定义，兼容性较差</li>
<li>BOM比DOM大，document包含在window里</li>
</ul>
<h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><ul>
<li>window对象是浏览器的顶级对象，具有双重角色：<ol>
<li>它是JS访问浏览器窗口的一个接口</li>
<li>它是一个全局对象。<strong>定义在全局作用域中的变量、函数都会变成window对象的属性和方法</strong>，alert(),prompt()都属于window对象的方法，只是省略了而已</li>
<li>Window.name：是window下的一个特殊属性，为空</li>
</ol>
<ul>
<li>window对象的常见事件<ol>
<li>window.onlaod = function() {}  窗口加载事件：当文档内容完全加载完成后会触发该事件（图像、脚本、CSS文件等），调用处理函数<ul>
<li>有了window.onload就可以把JS代码写到页面元素的上方</li>
<li>只能写一个， 多个以最后一个为准</li>
<li>window.addEventListener(‘load’,function(){} ) 同理</li>
</ul>
</li>
<li>document.addEventListener(‘DOMContentLoaded’,fuction(){  } ) ：仅当DOM加载完成（不包括样式表，图片，flash等) 就开始加载事件</li>
<li>window.addEventListener(‘resize’,fuction(){} )  调整窗口大小事件：只要窗口大小发生像素变化，就会触发这个事件。<ul>
<li>经常利用这个事件完成响应式布局。处理函数中配合上  window.innerWidth：当前屏幕的宽度</li>
</ul>
</li>
<li>定时器：<ol>
<li>window.setTimeout(调用函数,[延迟的毫秒数]) ：满足时间条件调用函数，仅调用一次<ul>
<li>window在调用的时候可以省略</li>
<li>这个函数可以直接写函数还可以写 函数名（不用加()  )，在外部定义一个函数</li>
<li>我们经常给定时器加标识符 （名字）</li>
<li>setTimeout()：这是个回调函数。事件函数也是回调函数</li>
</ul>
</li>
<li>window.clearTimeout(timeoutID) : 关闭 setTimeout() 定时器（window可省略）</li>
<li>window.setInterval(调用函数,[延迟的毫秒数])：满足时间条件调用函数，重复调用</li>
<li>window.clearInterval(intervalID)：关闭 setInterval() 定时器 （window可省略）</li>
</ol>
<ul>
<li><strong>this的指向问题：</strong><ol>
<li>全局作用域或者普通函数中this指向全局变量window <strong>(定时器里面的this指向window)</strong></li>
<li>方法调用中谁调用this指向谁</li>
<li>构造函数中this指向构造函数的实例</li>
<li>立即执行函数指向window</li>
</ol>
</li>
<li>call()方法：可以改变this的指向</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="JS执行机制（异步与同步）"><a href="#JS执行机制（异步与同步）" class="headerlink" title="JS执行机制（异步与同步）"></a>JS执行机制（异步与同步）</h3><ul>
<li>JS执行机制：JS语言特点是单线程，同一时间只能做一件事。造成页面渲染不连贯。于是出现异步和同步<ol>
<li>先执行执行栈中的同步任务</li>
<li>异步任务（回调函数）放入任务队列中</li>
<li>一旦执行栈中的同步任务执行完成，系统会按次序读取任务队列中的异步任务，并将其放入执行栈中开始执行</li>
</ol>
<ul>
<li>同步任务：同步任务都在主线程上执行，形成一个执行栈</li>
<li>异步任务：JS的异步是通过回调函数实现的。（异步任务相关的回调函数添加到任务队列中，也称为消息队列）<ol>
<li>普通事件：如click,resize等</li>
<li>资源加载：如load,error等</li>
<li>定时器：setInterval,setTimeout等</li>
</ol>
<ul>
<li>异步进程处理：当回调函数的条件被触发时才会把回调函数放入任务队列中</li>
<li>事件循环：由于主线程不断重复获得任务、执行任务、再获取任务、再执行，这种机制被称为事件循环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><ul>
<li>location属性：是window对象的一个属性，用于获取或设置窗体的URL，并且可以解析URL，这个属性返回一个对象，所以也称为location对象</li>
<li>URL：统一资源定位符，是互联网上标准资源的地址。组成：<ul>
<li>protocol://host[:prot]/path/[?query]#fragment   (protocol 通信协议 ；host 主机域名；port 端口号；path 路径；query 参数；fragment 片段)</li>
</ul>
</li>
<li>location对象的属性：<ol>
<li><strong>location.href：获取或者设置整个URL</strong> </li>
<li>location.host：返回主机</li>
<li><strong>location.search：返回参数</strong></li>
</ol>
</li>
<li>location对象的方法：<ol>
<li>location.assign()：跟href一样，可以跳转页面（记录历史，可实现后退功能，也称为重定向网页）</li>
<li>location.replace()：能实现跳转，但是不记录历史，不可实现后退功能</li>
<li>location.reload()：重新加载页面，相当于刷新按钮，如果参数为true 强制刷新 Ctrl+F</li>
</ol>
</li>
</ul>
<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><ul>
<li>可判断浏览器打开的是移动端还是PC端 P265</li>
</ul>
<h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><ul>
<li>实现页面前进和后退效果 P286</li>
</ul>
<h3 id="网页特效"><a href="#网页特效" class="headerlink" title="网页特效"></a>网页特效</h3><ol>
<li>offset系列：获得元素距离带有定位父元素的位置；获得元素自身大小</li>
</ol>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul>
<li>特性：<ol>
<li>数据存储在用户浏览器中</li>
<li>设置、读取方便、页面刷新不丢失数据</li>
<li>容量较大，sessionStorage约5M、localStorage约20Math </li>
<li>只能存储字符串，可以将对象JSON.stringify()编码后存储</li>
</ol>
</li>
</ul>
<p>(以下window.均可省略）</p>
<ul>
<li><p>window.sessionStorage.setItem（’key’,value)：存储数据</p>
<ol>
<li>生命周期为关闭浏览器窗口</li>
<li>在同一个窗口（页面）下数据可以共享</li>
<li>以键值对的形式存储</li>
</ol>
</li>
<li><p>window.sessionStorage.getItem（’key’)：读取数据</p>
</li>
<li><p>window.sessionStorage.removeItem（’key’)：删除数据</p>
</li>
<li><p>window.sessionStorage.clear（）：清空所有数据</p>
</li>
<li><p>window,localStorage（’key’,value)：存储数据</p>
<ol>
<li>生命周期永久生效，除非手动删除，否则关闭页面也会存在</li>
<li>可以多窗口（页面）共享（同一浏览器共享）</li>
<li>以键值对的形式存储使用</li>
</ol>
</li>
<li><p>window.localStorage.getItem（’key’)：读取数据</p>
</li>
<li><p>window.localStorage.removeItem（’key’)：删除数据</p>
</li>
<li><p>window.localStorage.clear（）：清空所有数据</p>
</li>
</ul>
<h1 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h1><h2 id="面向对象编程介绍"><a href="#面向对象编程介绍" class="headerlink" title="面向对象编程介绍"></a>面向对象编程介绍</h2><ul>
<li>面向过程：按照我们分析好了的步骤，按照步骤解决问题</li>
<li>面向对象：是以对象功能来划分问题，而不是步骤：<ul>
<li>特性：封装性 继承性 多态性</li>
</ul>
</li>
</ul>
<h2 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h2><ul>
<li><p>面向对象的思维特点：</p>
<ol>
<li>抽取对象共用的属性和行为组织（封装）成一个类（模板）</li>
<li>和类进行实例化，获取类的对象</li>
</ol>
</li>
<li><p>ES6中新增了类的概念，可以使用<strong>class</strong>关键字声明一个类，之后以这个类来实例化对象</p>
<ul>
<li>类抽象了对象的公共部分，它泛指某一大类（class）</li>
<li>对象特指某一个，通过类实例化一个具体的对象</li>
</ul>
</li>
<li><p>创建类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class name&#123;</span><br><span class="line">	//class body</span><br><span class="line">&#125;</span><br><span class="line">var xx = new name();</span><br></pre></td></tr></table></figure></li>
<li><p>类必须使用new实例化对象</p>
<ul>
<li>类名习惯定义首字母大写</li>
<li>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象</li>
<li>生成实例 类名后面加小括号，构造函数不需要加function</li>
</ul>
</li>
<li><p>类中添加方法：</p>
<ul>
<li><strong>类里面所有的函数不需要写function</strong></li>
<li>多个函数方法之间不需要添加逗号分隔</li>
</ul>
</li>
<li><p>类的继承:继承父级的属性和方法</p>
<ul>
<li>class Son extends Father{  }</li>
<li>super关键字：调用父类中的构造函数，也可以调用父类的普通函数<strong>（必须先调用父级的构造函数，才能使用子类的方法）</strong></li>
<li>继承中的属性或者方法查找原则：就近原则<ul>
<li>继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的</li>
<li>继承中，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法</li>
</ul>
</li>
</ul>
</li>
<li><p>ES6中类没有变量提升，必须先定义类，再通过类名实例化</p>
</li>
<li><p>类里面的共有的属性和方法一定要加this使用</p>
</li>
<li><p>类中this的指向问题：</p>
<ul>
<li><strong>constructor 里面的this 指向的是 创建的实例对象。方法里面的this指向这个方法的调用者</strong></li>
</ul>
</li>
<li><p>appendChild不支持追加字符串的子元素，insertAdjacentHTML支持追加字符串的元素</p>
</li>
</ul>
<h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><ul>
<li><p>构造函数：</p>
<ul>
<li>实例成员：构造函数内部通过this添加的成员，只能通过实例化的对象来访问</li>
<li>静态成员：在构造函数本身上添加的成员，只能通过构造函数访问</li>
</ul>
</li>
<li><p>构造函数存在浪费内存的问题</p>
<ul>
<li>构造函数原型对象 prototype：每一个构造函数都有一个prototype属性（它是一个对象）指向原型对象</li>
<li>解决方法：可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法（共享方法）</li>
</ul>
</li>
<li><p>一般情况下，我们的公共属性定义到构造函数里面，公共方法我们放到原型对象prototype里面</p>
</li>
<li><p>对象原型__proto__：对象都会有一个属性__proto__，指向构造函数的prototype原型对象</p>
</li>
<li><p>方法的查找规则：先看对象本身是否有xx方法，如果有就执行这个方法，如果没有xx方法，因为有__proto__的存在，就去构造函数原型对象prototype身上去查找xx方法</p>
</li>
<li><p>对象原型（__proto__）和构造函数原型对象（prototype）里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身（如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则我们需要手动利用constructor 这个属性指回原来的构造函数）</p>
</li>
<li><p>原型链：</p>
<ul>
<li>原型对象里面的__proto__原型指向的是object.prototype<br><img src="https://github.com/Mumujio/photoRepository/raw/master/github%E5%9B%BE%E7%89%87/photo/%E5%8E%9F%E5%9E%8B%E9%93%BE.png?raw=true"></li>
</ul>
</li>
<li><p>JS的成员查找机制（规则）<br><img src="https://github.com/Mumujio/photoRepository/raw/master/github%E5%9B%BE%E7%89%87/photo/Js%E7%9A%84%E6%88%90%E5%91%98%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6.png?raw=true"></p>
</li>
<li><p>原型对象中this指向：</p>
<ol>
<li>在构造函数中，里面this指向的是对象实例</li>
<li>原型对象函数里面的this 指向的是实例对象</li>
</ol>
</li>
<li><p>拓展内置对象</p>
<ul>
<li>可以通过原型对象，拓展内置方法对象</li>
<li>数组和字符串内置对象不能给原型对象覆盖操作Array.prototype={ }，只能是Array.protype.xxx=fuction(){ }的方式</li>
</ul>
</li>
</ul>
<h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><ul>
<li>ES6之前没有提供extends继承。我们可以通过构造函数+原型对象模拟实现继承（组合继承）</li>
</ul>
<ol>
<li>call()：调用这个函数，并且修改函数运行时的this指向<ul>
<li>fun.call(thisArg, arg1 ,arg2, …)：thisArg 当前调用函数this的指向对象 ；arg1 , arg2 传递的其他参数</li>
<li>call()可以调用函数：fn.call()</li>
<li>call()可以改变this指向：fn.call(o，1，2)：fn函数的this指向 o 对象，并传递了 1  2 两个参数</li>
</ul>
</li>
</ol>
<ul>
<li>借用父构造函数继承属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Father(uname,age)&#123;</span><br><span class="line">	this.uname = uname;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(uname,age)&#123;</span><br><span class="line">	Father.call(this,uname,age)// 调用Father构造函数，把父构造函数的this指向改为指向子构造函数的实例</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>借用父构造函数继承方法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Father.prototype.money = function()&#123;</span><br><span class="line">	xxx //父的方法</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = new Father();</span><br><span class="line">console.log(Son); </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ES5中新增的方法"><a href="#ES5中新增的方法" class="headerlink" title="ES5中新增的方法"></a>ES5中新增的方法</h2><ol>
<li><p>数组方法：</p>
<ul>
<li>迭代（遍历）方法：<ol>
<li>array.forEach(function(currentValue,index,arr){})：currentValue：数组当前项的值；index：数组当前项的索引；arr：数组对象本身</li>
<li>array.filter(function(currentValue,index,arr){})：currentValue：数组当前项的值；index：数组当前项的索引；arr：数组对象本身<ul>
<li>filter方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，<strong>主要用于筛选数组</strong></li>
<li><strong>它直接返回一个新数组</strong></li>
</ul>
</li>
<li>array.some(function(currentValue,index,arr){})：currentValue：数组当前项的值；index：数组当前项的索引；arr：数组对象本身<ul>
<li>some()方法通常用于查找数组中是否有满足条件的元素</li>
<li><strong>它返回值时布尔值，如果查找到这个元素就返回true，如果查找不到就返回false</strong></li>
<li><strong>如果找到第一个满足条件的元素，则终止循环</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>字符串方法：</p>
<ul>
<li>str.trim()：去除字符串两侧的空格。返回一个新的字符串，不影响字符串本身</li>
</ul>
</li>
<li><p>对象方法：</p>
<ul>
<li>Object.keys(obj)：用于获取对象自身的所有属性名。返回一个由属性名组成的数组</li>
<li>Object.defineProperty(obj,’prop’,descriptor)：定义对象中新属性或修改原有的属性 （obj 对象；prop 属性；descriptor 特性；都需要有）<ul>
<li>descript：以对象形式{}书写。<ul>
<li>value：设置属性的值 默认为undefined</li>
<li>writable：值是否可以重写。true|flase 默认为false</li>
<li>enumerable：目标属性是否可有被枚举。true|flase 默认为false</li>
<li>configurable：目标属性是否可以被删除或是否可以再次修改特性。true|flase 默认为false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="函数的进阶"><a href="#函数的进阶" class="headerlink" title="函数的进阶"></a>函数的进阶</h2><ol>
<li><p>函数的定义和调用</p>
<ul>
<li>var fn = new Function(‘参数1’，’参数2’… , ‘函数体’)<ul>
<li>所有函数都是 Function 的实例。函数也属于对象</li>
</ul>
</li>
</ul>
</li>
<li><p>函数的调用方式</p>
<ol>
<li>普通函数：<ul>
<li>fn()</li>
<li>fn().call</li>
</ul>
</li>
<li>对象的方法：<ul>
<li>obj.fn()</li>
</ul>
</li>
<li>构造函数：<ul>
<li>new fn();</li>
</ul>
</li>
<li>绑定事件函数：<ul>
<li>btn.onclick = function() {} //点击了按钮就可以调用这个函数</li>
</ul>
</li>
<li>定时器函数：<ul>
<li>setInterval(function() {} , 1000) //这个函数定时器自动1秒调用一次</li>
</ul>
</li>
<li>立即执行函数：<ul>
<li>(function(){ xxxx }) () ：自动调用</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>this指向问题：</strong></p>
<ul>
<li>函数的<strong>不同调用方式</strong>决定了this 的指向不同</li>
</ul>
<ol>
<li>普通函数：this指向window</li>
<li>对象的方法：this指向方法的调用者</li>
<li>构造函数：this指向实例对象。原型对象里面的this指向的是实例对象</li>
<li>绑定事件函数：this指向事件源（函数的调用者）</li>
<li>定时器函数：this指向window</li>
<li>立即执行函数：this指向window</li>
</ol>
<ul>
<li><strong>改变函数内部的this指向</strong>：<ol>
<li>call()方法：call的主要作用可以实现继承        </li>
<li>apply()方法：调用函数，改变函数的this指向：<ul>
<li>fun.apply(thisArg,[argsArray])：（thisArg this的指向；[argsArrgs]  参数以数组形式传入）</li>
<li>主要运用：利用 apply 借助于数学内置对象求最大值（ Math.max.apply(Math,arr) )</li>
</ul>
</li>
<li>bind()方法：<ul>
<li>fun.bind(thisArg,arg1,arg2,…)：返回由指定的this值和初始化参数改造的原函数拷贝 （thisArg fun函数运行时指定的this值；arg 传递的其它参数）</li>
</ul>
<ol>
<li>不会调用原来的函数 不可以改变原来函数内部的this 指向</li>
<li>返回的才是原函数改变this之后产生的新函数的拷贝</li>
<li>适用于函数不需要立即调用，但是又想改变这个函数内部的this指向</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul>
<li>JS还提供了严格模式（略）</li>
</ul>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul>
<li>高阶函数：是对其他函数进行操作的函数，它接收函数作为参数 或 将函数作为返回输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn(a,b.callback)&#123;</span><br><span class="line">	console.log(a+b);</span><br><span class="line">	callback &amp;&amp; callback();//回调函数</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,function()&#123;</span><br><span class="line">	console.log(&#x27;我是最后调用的&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>回调函数里的代码是最后运行的</li>
</ul>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>闭包：指有权访问另一个函数作用域中变量的 <strong>函数</strong>（被访问的函数称为闭包函数）</li>
<li>当函数执行完毕，本作用域内的局部变量会销毁<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//闭包：我们fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num</span><br><span class="line">function()&#123;</span><br><span class="line">	var num=10;</span><br><span class="line">	function fun()&#123;</span><br><span class="line">		console.log(num);</span><br><span class="line">	&#125;</span><br><span class="line">	fun();</span><br><span class="line">&#125;</span><br><span class="line">fn(); //10</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//闭包：我们fn 外面的作用域可以访问fn 内部的局部变量</span><br><span class="line">function()&#123;</span><br><span class="line">	var num=10;</span><br><span class="line">	function fun()&#123;</span><br><span class="line">		console.log(num);</span><br><span class="line">	&#125;</span><br><span class="line">	return fun;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn();</span><br><span class="line">f();//10</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的主要作用：延申了变量的作用范围</li>
<li>立即执行函数：（也称为小闭包，因为立即执行函数里面的任何一个函数都可以使用它的传入的参数这个变量）<ul>
<li> (function(){  xxxx })(给自己传的参数)</li>
</ul>
</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>如果函数在内部可以调用其本身，那么这个函数就是递归函数（函数内部自己调用自己，这个函数就是递归函数）</li>
<li>递归函数的作用和循环效果一样。<strong>很容易发生“栈溢出”的错误，所以必须要加退出循环条件return</strong></li>
</ul>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul>
<li><p>浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用（即拷贝地址）</p>
<ul>
<li>Object.assign(target,…sources)：es6新增方法可以浅拷贝 （target 拷贝者；sources 被拷贝者）（浅拷贝方法）、</li>
</ul>
</li>
<li><p>深拷贝拷贝多层，每一级别的数据都会拷贝</p>
<ul>
<li>使用递归来完成</li>
</ul>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>是用于匹配字符串中字符组合的模式，在JS中，正则表达式也是对象</li>
<li>通常被用于：检索和替换符合某个规则的文本 过滤敏感词  从字符串中获取特定部分</li>
<li>特点：<ol>
<li>灵活性、逻辑性、功能性非常强</li>
<li>便捷达到字符串的复杂控制</li>
<li>实际开发，一般都是直接复制写好的正则表达式</li>
</ol>
</li>
<li>使用：<ol>
<li>创建正则表达式：<ol>
<li>通过调用RegExp对象的构造函数创建：var 变量名 = new RegExp(/表达式/)</li>
<li>利用字面量创建：var 变量名 = /表达式/ （常用）</li>
</ol>
</li>
<li>测试正则表达式test：<ul>
<li>test()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数是测试字符串</li>
<li>语法：regexobj.test(‘str’)   （regexObj 我们写的正则表达式；str 我们要测试的文本）（就是检测str文本是否符合我们写的正则表达式规范）</li>
</ul>
</li>
</ol>
</li>
<li>正则表达式的组成：<ul>
<li>正则表达式里面不需要加引号 ，不管是数字型还是字符串型</li>
</ul>
<ol>
<li>限定符：用来设定某个模式出现的次数<ol>
<li>? ：代表前面的字符可出现一次或0次( 1 || 0 )</li>
<li>*： 代表前面的字符可有可无，可多可少（&gt;=0）</li>
<li>+：匹配出现<strong>一次以上</strong>的字符（&gt;0）</li>
<li>{2，6}：前面字符出现的次数在2-6之间；{2 , }  出现大于等于2次</li>
<li>（ab）：匹配ab字符</li>
</ol>
</li>
<li>或运算符：<ul>
<li> a (cat | dog)：匹配 a cat或 a dog</li>
</ul>
</li>
<li>字符类：表示有一系列字符可供选择，只要匹配其中 一个 就可以了（可供选择的字符都放在方括号里）<ul>
<li>[a-z]：匹配所有小写英文字符</li>
<li>[a-zA-Z]：匹配所有英文字符</li>
<li>[a-zA-Z0-9]：匹配所有英文字符和数字</li>
<li>[a-zA-Z0-9_-]：等等</li>
<li>[^  ] ：匹配除了 ^ 后面列出的以外的字符（取反）</li>
<li>/^[abc]$/  // 三选一 只有是a 或者是 b 或者是c</li>
</ul>
</li>
<li>元字符：某些常见模式的简写方式<ol>
<li>\d：数字 （等于 [0-9]）（\D 非数字）</li>
<li>\w：任意字母、数字、下划线 （等于[a-zA-Z0-9]）（\W 非单词）</li>
<li>\s：空白符（包括tab和换行 制表） （\S 非空白字符）</li>
<li>. ：任意字符（不包括换行符）</li>
</ol>
</li>
<li>边界符<ol>
<li>^a：匹配行首a</li>
<li>$a：匹配行尾a</li>
</ol>
<ul>
<li>精确匹配：/^abc$/  // 要求必须是 abc字符串才符合规范</li>
</ul>
</li>
<li>贪婪与懒惰匹配：<ol>
<li> &lt;.+&gt;：正则表达式默认的贪婪匹配‘任意字符’</li>
<li>&lt;.+?&gt;：懒惰匹配‘任意字符’</li>
</ol>
</li>
</ol>
</li>
<li>正则表达式的替换：<ul>
<li>replace()方法：实现替换字符串操作，替换的参数可以是一个字符串或是一个正则表达式</li>
<li>stringObject.replace(regexp/substr,replacement)：第一个参数被替换的  第二个替换者  返回值是一个替换完毕的 新 字符串（替换后不会继续替换）</li>
</ul>
</li>
<li>正则表达式参数：<ul>
<li>/表达式/[switch]：switch（也称修饰符）<ol>
<li>g：全局匹配</li>
<li>i：忽略大小写</li>
<li>gi：全局匹配+忽略大小写 </li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="ES6-ES11篇"><a href="#ES6-ES11篇" class="headerlink" title="ES6-ES11篇"></a>ES6-ES11篇</h1><ul>
<li>ES新特性其实指的是JavaScript的新特性</li>
</ul>
<h2 id="let声明变量以及声明特性"><a href="#let声明变量以及声明特性" class="headerlink" title="let声明变量以及声明特性"></a>let声明变量以及声明特性</h2><ul>
<li>变量不能重复声明：同一变量名不能重复声明不同的值</li>
<li><strong>块级作用域</strong>：let声明的变量只在所在代码块里使用 （if else while for中也存在）（不影响作用域链）</li>
<li>不存在变量提升：let不存在变量提升</li>
<li>具有暂时性死区，会和声明的块级区域绑定，在区域内使用这个变量和外部没有关系<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num =10 ;</span><br><span class="line">if (true)&#123;</span><br><span class="line">	console.log(num); // Cannot access &#x27;num&#x27; before initialization</span><br><span class="line">	let num =20;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="const声明常量以及特点"><a href="#const声明常量以及特点" class="headerlink" title="const声明常量以及特点"></a>const声明常量以及特点</h2><ul>
<li>const一定要赋初始值</li>
<li>一般常量使用大写（潜规则）</li>
<li>常量的值不能修改</li>
<li>也是块级作用域</li>
<li>对于数组和对象的元素修改，不算做常量的修改，不会报错</li>
</ul>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><ol>
<li>数组的解构<ul>
<li>允许我们按照一一对应的关系从数组中提取值，然后将值赋值给变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let ary=[1,2,3]</span><br><span class="line">let [a,b,c,d,e] = ary;</span><br><span class="line">console.log(a) //1</span><br><span class="line">console.log(b) //2</span><br><span class="line">console.log(c) //3</span><br><span class="line">console.log(d) // undefined</span><br><span class="line">console.log(e) // undefined</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>对象的解构<ul>
<li>按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;name: &#x27;zhangsan&#x27; , age:20 &#125;;</span><br><span class="line">let &#123;name,age&#125; = person;</span><br><span class="line">console.log(name); //&#x27;zhangsan&#x27;</span><br><span class="line">console.log(age); //&#x27;20&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let &#123;name:myname  , age:myage &#125;=person; //myname myage属于别名</span><br><span class="line">console.log(myname);//&#x27;zhangsan&#x27;</span><br><span class="line">console.log(myage);//&#x27;20&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul>
<li>` 反引号：反引号可声明字符串，可以出现字符串<ul>
<li>可以直接进行变量的拼接：<code>$&#123;变量名&#125;字符串内容</code></li>
</ul>
</li>
</ul>
<h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><ul>
<li>允许在大括号里面，直接写入变量和函数，作为对象的属性和方法（对象内方法的创建可以省略fuction）</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li>箭头 =&gt;：声明函数：let fn = () =&gt; {   }  （小括号里形参）</li>
<li>特性：<ol>
<li><strong>this 是静态的：this始终指向函数声明时所在作用域下的this的值</strong></li>
<li>不能作为构造实例化对象</li>
<li>不能使用arguments变量（保存实参）</li>
<li>箭头函数的简写：<ol>
<li>省略小括号：当形参有且只有一个的时候</li>
<li>省略花括号：当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是函数的返回值</li>
</ol>
</li>
</ol>
</li>
<li>箭头函数的运用场景：<ol>
<li>适合与 this 无关的回调：定时器，数组的方法回调</li>
<li>不适合与this有关的回调 ：（事件回调，对象的方法）</li>
</ol>
</li>
</ul>
<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><ul>
<li>ES6允许给函数参数赋值初始值（形参）（具有初始值的形参，一般位置要靠后）</li>
<li>与解构赋值结合</li>
</ul>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><ul>
<li>用于获取函数的实参，用来代替arguments<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function date(...args)&#123;</span><br><span class="line">	console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">date(&#x27;阿娇&#x27;，&#x27;博智&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>rest参数必须要放到参数最后</li>
</ul>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><ul>
<li>… [数组或数组名]：能将[数组]转换为逗号分割的[参数序列]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const tfboys = [&#x27;爸爸&#x27;,&#x27;妈妈&#x27;,&#x27;儿子&#x27;]</span><br><span class="line">function chuanwan()&#123;</span><br><span class="line">	console.log(arguments); </span><br><span class="line">&#125;</span><br><span class="line">chunwan(...tfboys) // 等价于 chunwan(&#x27;爸爸&#x27;,&#x27;妈妈&#x27;,&#x27;儿子&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>运用：<ol>
<li>数组的合并</li>
<li>数组的克隆</li>
<li>将伪数组转换为真数组</li>
</ol>
</li>
</ul>
<h2 id="Symbol的基本使用"><a href="#Symbol的基本使用" class="headerlink" title="Symbol的基本使用"></a>Symbol的基本使用</h2><ul>
<li><p>一种新的数据类型，表示独一无二的值。<strong>是JS的第七种数据类型</strong></p>
</li>
<li><p>特点：</p>
<ol>
<li>Symbol的值是唯一的，用来解决命名冲突的问题</li>
<li>Symbol值不能与其他数据进行运算</li>
<li>Symbol定义的对象属性不能使用for in 循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</li>
</ol>
</li>
<li><p>创建Symbol</p>
<ol>
<li>let s = Symbol()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s2 = Symbol(&#x27;尚硅谷&#x27;);</span><br><span class="line">let s3 = Symbol(&#x27;尚硅谷&#x27;)；</span><br><span class="line">console.log(s2 === s3) //false</span><br></pre></td></tr></table></figure></li>
<li>let s4 = Symbol.for(‘尚硅谷’)；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s4 = Symbol(&#x27;尚硅谷&#x27;);</span><br><span class="line">let s5 = Symbol(&#x27;尚硅谷&#x27;)；</span><br><span class="line">console.log(s4 === s5) //false</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>不能与其他数据类型比较和运算（包括Symbol自身的数据类型）</p>
</li>
<li><p>Symbol创建对象属性：</p>
<ol>
<li>向对象中添加方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let youxi = &#123;</span><br><span class="line">	[Symbol(&#x27;say&#x27;)]: function()&#123;</span><br><span class="line">	xxxxxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Symbol的内置值：</p>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator 接口，就可以完成遍历操作</li>
<li>ES6创造了一种新的遍历命令for…of循环，iterator接口（对象的一个属性）主要供for…of消费</li>
<li>原生具备iterator接口的数据（可用for of循环）：<ul>
<li>Array  Arguments Set Map String TypedArray NodeList</li>
</ul>
</li>
<li><strong>for of循环中变量保存的是键值，for in循环中变量保存的是键名</strong></li>
<li>工作原理：<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置</li>
<li>第一次调用对象的next方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用nest方法，指针一直在往后移动，直到指向最后一个成员</li>
<li>每调用nest方法返回一个包含value和done属性的对象</li>
</ol>
</li>
</ul>
<h1 id="jQuery篇"><a href="#jQuery篇" class="headerlink" title="jQuery篇"></a>jQuery篇</h1><ul>
<li>JavaScript库：是一个封装好的特定的集合。</li>
<li>jQuery：就是一个JS库，为了快速方便的操作DOM，里面基本都是函数（方法）</li>
<li>优点：基本兼容了现在主流的浏览器，免费，开源</li>
</ul>
<h2 id="jQuery的基本使用"><a href="#jQuery的基本使用" class="headerlink" title="jQuery的基本使用"></a>jQuery的基本使用</h2><ul>
<li>$(function() {  } )  入口函数；等DOM结构渲染完毕即可执行内部函数</li>
<li>jQuery的顶级对象 $ ：$是jQuery的别称，也是jQuery的顶级对象</li>
<li>jQuery对象：用jquery方式获取过来的对象是jquery对象，本质：通过$多DOM对象包装后产生的对象（为数组形式储存）<ul>
<li><strong>JQ对象只能使用JQ方法，DOM对象则使用原生的JS属性和方法</strong></li>
</ul>
</li>
<li>DOM对象与JQ对象之间是可以相互转换的：原生JS比JQ更大，一些JQ没有封装的就需要把JQ对象转换为DOM对象使用<ol>
<li>DOM对象转换为JQ对象：$(DOM对象)<ul>
<li>JQ中没有play这个方法</li>
</ul>
</li>
<li>JQ对象转换为DOM对象：<ul>
<li>$(‘div’)[index]   index是索引号</li>
<li>$(‘div’).get(index)   index是索引号<h3 id="JQ常用的API"><a href="#JQ常用的API" class="headerlink" title="JQ常用的API"></a>JQ常用的API</h3></li>
</ul>
</li>
</ol>
</li>
<li>JQ的基础选择器  $(“选择器”)：里面选择器直接写CSS选择器即可，但是要<strong>加引号</strong></li>
<li>JQ的层级选择器 ：和CSS差不多</li>
<li>JQ隐式迭代：遍历内部DOM元素（伪数组形式储存）的过程叫隐式迭代；给匹配到的所有元素进行遍历循环，执行相应的方法。而不用我们再进行循环。</li>
<li>JQ筛选选择器：<ol>
<li>$(‘li:first’)：获取第一个li元素</li>
<li>$(‘li:last’)：获取最后一个li元素</li>
<li>$”li:eq(2)”：获取到的li元素中，选择索引号为2的元素，索引号index从0开始</li>
<li>$(“li:odd”)：获取到的li元素中，选择索引号为奇数的元素</li>
<li>$(“li:even”)：获取到的li元素中，选择索引号为偶数的元素</li>
</ol>
</li>
<li>JQ筛选方法：<br><img src="https://github.com/Mumujio/photoRepository/raw/master/github%E5%9B%BE%E7%89%87/photo/4.png?raw=true"></li>
</ul>
<h1 id="Ajax篇"><a href="#Ajax篇" class="headerlink" title="Ajax篇"></a>Ajax篇</h1><ul>
<li>上网过程中，负责存放和对外提供资源的电脑，叫做服务器</li>
<li>在上网过程中，负责获取和消费资源的电脑，叫做客户端</li>
</ul>
<h2 id="URL地址"><a href="#URL地址" class="headerlink" title="URL地址"></a>URL地址</h2><ul>
<li>URL：统一资源定位符。用于标识互联网上每个资源的唯一储存位置<ul>
<li>由三部分组成：<ol>
<li>客户端与服务端的通信协议</li>
<li>存有该资源的服务器名称</li>
<li>资源在服务器的集体存放位置<h2 id="客户端与服务器的通信过程"><a href="#客户端与服务器的通信过程" class="headerlink" title="客户端与服务器的通信过程"></a>客户端与服务器的通信过程</h2><img src="C:\Users\JayZ\Desktop\markdow图片\5.png"></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="服务器对外提供了哪些资源"><a href="#服务器对外提供了哪些资源" class="headerlink" title="服务器对外提供了哪些资源"></a>服务器对外提供了哪些资源</h2><ul>
<li>网页中常见的资源：文字内容、img图片、Audio音频、Video视频</li>
<li>网页中的数据也是服务器对外的一种资源</li>
<li>资源必然要通过 请求-处理-响应的方式进行获取：<ul>
<li>如果要在网页中请求服务器上的资源数据，则需要 <strong>XMLHttpRequest  (简称xhr) 对象</strong>：是浏览器提供的js成员，可以请求服务器资源 </li>
<li>xhr的使用：var xhrObj = new XMLHttpRequest()</li>
</ul>
</li>
</ul>
<h2 id="了解Ajax"><a href="#了解Ajax" class="headerlink" title="了解Ajax"></a>了解Ajax</h2><ul>
<li>在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax (异步Js和XML）</li>
<li>Ajax让我们轻松实现网页与服务器之间的数据交互</li>
<li>资源请求方式：最常见的是get和post请求<ul>
<li>get请求通常用于<strong>获取服务端资源</strong>：例如根据URL地址，从服务器获取HTML文件、css文件、js文件等等</li>
<li>post请求通常用于向<strong>服务器提交资源</strong>：例如登陆时向服务器提交登陆信息、注册时向服务器提交注册信息德等数据提交操作</li>
</ul>
</li>
</ul>
<h2 id="JQ-中的Ajax"><a href="#JQ-中的Ajax" class="headerlink" title="JQ 中的Ajax"></a>JQ 中的Ajax</h2><ul>
<li>JQ中的Ajax：JQ对Ajax进行了封装，极大地降低了Ajax的使用难度</li>
<li>JQ中发起Ajax请求最常用的三个方法：<ol>
<li>$.get()：<ul>
<li>$.get(url,[date],[callback])：url(要请求的资源地址)；date(请求资源期间要携带的参数)；callback(请求成功时的回调函数)</li>
</ul>
</li>
<li>$.post()<ul>
<li>$.post(url,[date],[callback])：url(要请求的资源地址)；date(请求资源期间要携带的参数)；callback(请求成功时的回调函数)</li>
</ul>
</li>
<li><em><strong>ajax()</strong></em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	type：‘’, // 请求的方式，例如 GET 或 POST</span><br><span class="line">	url：&#x27;&#x27;  ,//请求的URL地址</span><br><span class="line">	date:&#123;  &#125;,// 这次请求要携带的数据</span><br><span class="line">	success: function(res)&#123; &#125;// 请求成功之后的回调函数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>千万不要打赏</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt=" 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt=" 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/02/26/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8hexo-next/" rel="next" title="初次使用hexo+next">
                <i class="fa fa-chevron-left"></i> 初次使用hexo+next
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/02/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="prev" title="浏览器的执行机制">
                浏览器的执行机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://tse1-mm.cn.bing.net/th/id/R-C.8d895e16bbb22a83310865f234dd9f3f?rik=VxdPPnUQI85owQ&riu=http%3a%2f%2f5b0988e595225.cdn.sohucs.com%2fimages%2f20191230%2fa7b693fd6434409585045f5887583e7c.jpeg&ehk=0aIPIvL4wupp6ImoUjS%2fxpd0ULtX5T6li3I%2fbywpfHo%3d&risl=&pid=ImgRaw&r=0"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Mumujio" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-%E7%AF%87"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%BB"><span class="nav-number">1.1.</span> <span class="nav-text">导读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8B%93%E5%B1%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量的语法拓展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.1.</span> <span class="nav-text">算数运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.2.</span> <span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.4.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.4.5.</span> <span class="nav-text">运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.5.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.7.</span> <span class="nav-text">JS 作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.7.1.</span> <span class="nav-text">变量的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">1.7.2.</span> <span class="nav-text">作用域链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-%E9%A2%84%E8%A7%A3%E6%9E%90"><span class="nav-number">1.8.</span> <span class="nav-text">JS 预解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.9.</span> <span class="nav-text">JS 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">1.9.1.</span> <span class="nav-text">JS 对象的创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.9.2.</span> <span class="nav-text">new关键字的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.9.3.</span> <span class="nav-text">遍历对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.9.4.</span> <span class="nav-text">JS的内置对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.10.</span> <span class="nav-text">数据类型的内存分配</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web-API%E9%98%B6%E6%AE%B5"><span class="nav-number">2.</span> <span class="nav-text">Web API阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM"><span class="nav-number">2.1.</span> <span class="nav-text">DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.1.</span> <span class="nav-text">获取元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.2.</span> <span class="nav-text">事件基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.3.</span> <span class="nav-text">操作元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.4.</span> <span class="nav-text">节点操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7"><span class="nav-number">2.1.5.</span> <span class="nav-text">事件高级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BOM"><span class="nav-number">2.2.</span> <span class="nav-text">BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#window%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.1.</span> <span class="nav-text">window对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">JS执行机制（异步与同步）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#location%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.3.</span> <span class="nav-text">location对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#navigator%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.4.</span> <span class="nav-text">navigator对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#history%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.5.</span> <span class="nav-text">history对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88"><span class="nav-number">2.2.6.</span> <span class="nav-text">网页特效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">2.3.</span> <span class="nav-text">本地存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS%E9%AB%98%E7%BA%A7"><span class="nav-number">3.</span> <span class="nav-text">JS高级</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">面向对象编程介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.</span> <span class="nav-text">ES6中的类和对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">构造函数和原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="nav-number">3.4.</span> <span class="nav-text">继承：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES5%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.</span> <span class="nav-text">ES5中新增的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9B%E9%98%B6"><span class="nav-number">3.6.</span> <span class="nav-text">函数的进阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.7.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.9.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">3.10.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">3.11.</span> <span class="nav-text">深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.12.</span> <span class="nav-text">正则表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6-ES11%E7%AF%87"><span class="nav-number">4.</span> <span class="nav-text">ES6-ES11篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#let%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%A3%B0%E6%98%8E%E7%89%B9%E6%80%A7"><span class="nav-number">4.1.</span> <span class="nav-text">let声明变量以及声明特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">const声明常量以及特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">4.3.</span> <span class="nav-text">变量的解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.4.</span> <span class="nav-text">模板字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">简化对象写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">4.6.</span> <span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">4.7.</span> <span class="nav-text">参数默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rest%E5%8F%82%E6%95%B0"><span class="nav-number">4.8.</span> <span class="nav-text">rest参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.9.</span> <span class="nav-text">扩展运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">4.10.</span> <span class="nav-text">Symbol的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.11.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jQuery%E7%AF%87"><span class="nav-number">5.</span> <span class="nav-text">jQuery篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jQuery%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">5.1.</span> <span class="nav-text">jQuery的基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JQ%E5%B8%B8%E7%94%A8%E7%9A%84API"><span class="nav-number">5.1.1.</span> <span class="nav-text">JQ常用的API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ajax%E7%AF%87"><span class="nav-number">6.</span> <span class="nav-text">Ajax篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#URL%E5%9C%B0%E5%9D%80"><span class="nav-number">6.1.</span> <span class="nav-text">URL地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">6.2.</span> <span class="nav-text">客户端与服务器的通信过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90"><span class="nav-number">6.3.</span> <span class="nav-text">服务器对外提供了哪些资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3Ajax"><span class="nav-number">6.4.</span> <span class="nav-text">了解Ajax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JQ-%E4%B8%AD%E7%9A%84Ajax"><span class="nav-number">6.5.</span> <span class="nav-text">JQ 中的Ajax</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林卓</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 's9Bhx1jgtV1CB96MDz0JTVOF-gzGzoHsz',
        appKey: 'U6qNtvyyt5VG3HTJtATMCTUh',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
